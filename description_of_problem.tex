\chapter{Description of problem}
\label{cha:Description}

In this chapter an issue of the work is being explained. As usual a compare of two codes we can consider them as classes, functions or methods. Thereby a compare can be counted as examinations of two pieces of code, in the best case a methods or functions. They can have a similar implementation or alike syntax, however these two pieces of code are different.

There are many purposes to compare a code, to find out a similarity or determine a difference between them. One of the option is to search for plagiarism in case a code can be taken from external source and a variables have been changed. In addition to general search can be improved to look out a similar code in big projects.

If two graphs are being compared with each other, then it's NP - complete problem and takes much times and efforts to be done. Therefore this problem must to be reduced. Luckily, a tree comparison is able to executed in polynomial time and moreover there are some algorithms to compare them.
\\
TODO: write what is NP-complete, write a problems with time execution \\
TODO: create a pieces of code and compare them
\\

Thus there are no deterministic algorithms to compare them because of loops in graphs. In this case the input code can be transformed into graph firstly, after the graph creation, it must be converted into tree, using simple techniques removing back edges. The back edges are edges point out the same node. 

After described code transformation a three questions can be asked:
 1. how to transform code into tree optimally
 2. how to compare these trees
 3. how to reference code pieces and nodes(how to put the code difference) 

Regards to the first question, the concept of idea is described in section "Graph Transformation". The second question comprehends existing algorithm and their combination and improvements in chapter "Existing algorithms". The last issue is about how to lead back the result of the code.

TODO: look in internet what exists already(code compare)

Possible result of this thesis is development of concept to find out code difference using graph theory, in the best case a tool in Project Dr. Garbage \cite{drgarbage} . can be implemented that highlights similarity/difference of input code snippet and represented respective graph.

To get started searching optimal way to find similarity/difference two AST trees, compare them, find a logic how to link nodes with the code. Small example demonstrating, what kind of result gives text compare(just string compare)and AST:

TODO: highlight this code

	public void ast1(){
		if(i > 1) i++;\\
	}
	
	public void ast2(){
		if(i > 1) 
		i++;
	}
	
In this example, two pieces of code there one enter symbol after line (i > 1), therefore the codes look different. Using simple text compare approach, only these gap will be found, however this difference does not play any role regards business-logic. In Abstract Syntax View, these two graphs will be same, and no discrepancy will have been discovered.

TODO: create an example of AST and text compare
	
Since this article includes comparison not only of source code, from where an Abstract Syntax Tree can be easily build, but also Java byte code, where there is no syntax. Basically to have a look at byte code example, there are no bounds to hold a functions or methods. Based on this, 
control flow graph can be derived from byte code, that represents a graph, but not a spanning tree. Every node has a reference to byte code address.

TODO: is any idea how to optimize spanning tree(node has a byte code address, topologically sort)

TODO: find java bytecode example and his tree

IDEA: text difference highlight and in parallel nodes in Tree marks and Matching
(TODO: make some experiments, if it's ok, better, worse or same compare)

To investigate code comparison, two algorithms of structural compare are required, in fact Top down maximum common subtree and Bottom Up maximum common subtree algorithms.
To make a contribution into development of structured code compare, the following tasks should be explored:

\begin{enumerate}
  \item The existing algorithms must be investigated (The text-compare method is not sufficient to find a similarity in code)
  \item The algorithms for the structured compare(Abstract syntax trees, Control flow graphs) must be explored 
   \item New methods and algorithms find a place to tried out. A prototypes of combination text-compare and structure-compare can be implemented.
   \item Experimental results of compare must be derived.
\end{enumerate}

